#!/usr/bin/env bash
#
# ARG_HELP([synthstrip_N3 Human T1w Preprocessing])
# ARG_OPTIONAL_SINGLE([distance],[],[Initial distance for correction],[400])
# ARG_OPTIONAL_SINGLE([levels],[],[Levels of correction with distance halving],[4])
# ARG_OPTIONAL_SINGLE([cycles],[],[Cycles of correction at each level],[3])
# ARG_OPTIONAL_SINGLE([iters],[],[Iterations of correction for each cycle],[50])
# ARG_OPTIONAL_SINGLE([lambda],[],[Spline regularization value],[2.0e-6])
# ARG_OPTIONAL_SINGLE([fwhm],[],[Intensity histogram smoothing fwhm],[0.1])
# ARG_OPTIONAL_SINGLE([stop],[],[Stopping criterion for N3],[0.00001])
# ARG_OPTIONAL_SINGLE([isostep],[],[Isotropic resampling resolution in mm for N3],[4])
# ARG_OPTIONAL_SINGLE([prior-config],[],[Config file to use for models and priors],[mni_icbm152_nlin_sym_09c.cfg])
# ARG_OPTIONAL_SINGLE([lsq6-resample-type],[],[(Standalone) Type of resampling lsq6(rigid) output files undergo, can be "coordinates", "none", or a floating point value for the isotropic resolution in mni_icbm152_t1_tal_nlin_sym_09c space],[none])
# ARG_OPTIONAL_BOOLEAN([clobber],[c],[Overwrite files that already exist])
# ARG_OPTIONAL_BOOLEAN([verbose],[v],[Run commands verbosely],[off])
# ARG_OPTIONAL_BOOLEAN([debug],[d],[Show all internal commands and logic for debug],[])
# ARG_POSITIONAL_SINGLE([input],[Input MINC or NIFTI file])
# ARG_POSITIONAL_SINGLE([output],[Output MINC file, also used as basename for secondary outputs])
# ARGBASH_SET_INDENT([  ])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.11.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.dev for more info

die() {
  local _ret="${2:-1}"
  test "${_PRINT_HELP:-no}" = yes && print_help >&2
  echo "$1" >&2
  exit "${_ret}"
}

begins_with_short_option() {
  local first_option all_short_options='hcvd'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_distance="400"
_arg_levels="4"
_arg_cycles="3"
_arg_iters="50"
_arg_lambda="2.0e-6"
_arg_fwhm="0.1"
_arg_stop="0.00001"
_arg_isostep="4"
_arg_prior_config="mni_icbm152_nlin_sym_09c.cfg"
_arg_lsq6_resample_type="none"
_arg_clobber="off"
_arg_verbose="off"
_arg_debug="off"

print_help() {
  printf '%s\n' "synthstrip_N3 Human T1w Preprocessing"
  printf 'Usage: %s [-h|--help] [--distance <arg>] [--levels <arg>] [--cycles <arg>] [--iters <arg>] [--lambda <arg>] [--fwhm <arg>] [--stop <arg>] [--isostep <arg>] [--prior-config <arg>] [--lsq6-resample-type <arg>] [-c|--(no-)clobber] [-v|--(no-)verbose] [-d|--(no-)debug] <input> <output>\n' "$0"
  printf '\t%s\n' "<input>: Input MINC or NIFTI file"
  printf '\t%s\n' "<output>: Output MINC file, also used as basename for secondary outputs"
  printf '\t%s\n' "-h, --help: Prints help"
  printf '\t%s\n' "--distance: Initial distance for correction (default: '400')"
  printf '\t%s\n' "--levels: Levels of correction with distance halving (default: '4')"
  printf '\t%s\n' "--cycles: Cycles of correction at each level (default: '3')"
  printf '\t%s\n' "--iters: Iterations of correction for each cycle (default: '50')"
  printf '\t%s\n' "--lambda: Spline regularization value (default: '2.0e-6')"
  printf '\t%s\n' "--fwhm: Intensity histogram smoothing fwhm (default: '0.1')"
  printf '\t%s\n' "--stop: Stopping criterion for N3 (default: '0.00001')"
  printf '\t%s\n' "--isostep: Isotropic resampling resolution in mm for N3 (default: '4')"
  printf '\t%s\n' "--prior-config: Config file to use for models and priors (default: 'mni_icbm152_nlin_sym_09c.cfg')"
  printf '\t%s\n' "--lsq6-resample-type: (Standalone) Type of resampling lsq6(rigid) output files undergo, can be \"coordinates\", \"none\", or a floating point value for the isotropic resolution in mni_icbm152_t1_tal_nlin_sym_09c space (default: 'none')"
  printf '\t%s\n' "-c, --clobber, --no-clobber: Overwrite files that already exist (off by default)"
  printf '\t%s\n' "-v, --verbose, --no-verbose: Run commands verbosely (off by default)"
  printf '\t%s\n' "-d, --debug, --no-debug: Show all internal commands and logic for debug (off by default)"
}

parse_commandline() {
  _positionals_count=0
  local _key
  while test $# -gt 0; do
    _key="$1"
    case "$_key" in
    -h | --help)
      print_help
      exit 0
      ;;
    -h*)
      print_help
      exit 0
      ;;
    --distance)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_distance="$2"
      shift
      ;;
    --distance=*)
      _arg_distance="${_key##--distance=}"
      ;;
    --levels)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_levels="$2"
      shift
      ;;
    --levels=*)
      _arg_levels="${_key##--levels=}"
      ;;
    --cycles)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_cycles="$2"
      shift
      ;;
    --cycles=*)
      _arg_cycles="${_key##--cycles=}"
      ;;
    --iters)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_iters="$2"
      shift
      ;;
    --iters=*)
      _arg_iters="${_key##--iters=}"
      ;;
    --lambda)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_lambda="$2"
      shift
      ;;
    --lambda=*)
      _arg_lambda="${_key##--lambda=}"
      ;;
    --fwhm)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_fwhm="$2"
      shift
      ;;
    --fwhm=*)
      _arg_fwhm="${_key##--fwhm=}"
      ;;
    --stop)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_stop="$2"
      shift
      ;;
    --stop=*)
      _arg_stop="${_key##--stop=}"
      ;;
    --isostep)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_isostep="$2"
      shift
      ;;
    --isostep=*)
      _arg_isostep="${_key##--isostep=}"
      ;;
    --prior-config)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_prior_config="$2"
      shift
      ;;
    --prior-config=*)
      _arg_prior_config="${_key##--prior-config=}"
      ;;
    --lsq6-resample-type)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_lsq6_resample_type="$2"
      shift
      ;;
    --lsq6-resample-type=*)
      _arg_lsq6_resample_type="${_key##--lsq6-resample-type=}"
      ;;
    -c | --no-clobber | --clobber)
      _arg_clobber="on"
      test "${1:0:5}" = "--no-" && _arg_clobber="off"
      ;;
    -c*)
      _arg_clobber="on"
      _next="${_key##-c}"
      if test -n "$_next" -a "$_next" != "$_key"; then
        { begins_with_short_option "$_next" && shift && set -- "-c" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
      fi
      ;;
    -v | --no-verbose | --verbose)
      _arg_verbose="on"
      test "${1:0:5}" = "--no-" && _arg_verbose="off"
      ;;
    -v*)
      _arg_verbose="on"
      _next="${_key##-v}"
      if test -n "$_next" -a "$_next" != "$_key"; then
        { begins_with_short_option "$_next" && shift && set -- "-v" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
      fi
      ;;
    -d | --no-debug | --debug)
      _arg_debug="on"
      test "${1:0:5}" = "--no-" && _arg_debug="off"
      ;;
    -d*)
      _arg_debug="on"
      _next="${_key##-d}"
      if test -n "$_next" -a "$_next" != "$_key"; then
        { begins_with_short_option "$_next" && shift && set -- "-d" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
      fi
      ;;
    *)
      _last_positional="$1"
      _positionals+=("$_last_positional")
      _positionals_count=$((_positionals_count + 1))
      ;;
    esac
    shift
  done
}

handle_passed_args_count() {
  local _required_args_string="'input' and 'output'"
  test "${_positionals_count}" -ge 2 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 2 (namely: $_required_args_string), but got only ${_positionals_count}." 1
  test "${_positionals_count}" -le 2 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}

assign_positional_args() {
  local _positional_name _shift_for=$1
  _positional_names="_arg_input _arg_output "

  shift "$_shift_for"
  for _positional_name in ${_positional_names}; do
    test $# -gt 0 || break
    eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
    shift
  done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

set -uo pipefail
set -eE -o functrace

# Add handler for failure to show where things went wrong
failure_handler() {
  local lineno=$2
  local fn=$3
  local exitstatus=$4
  local msg=$5
  local lineno_fns=${1% 0}
  if [[ "$lineno_fns" != "0" ]]; then
    lineno="${lineno} ${lineno_fns}"
  fi
  echo "${BASH_SOURCE[1]}:${fn}[${lineno}] Failed with status ${exitstatus}: $msg"
}
trap 'failure_handler "${BASH_LINENO[*]}" "$LINENO" "${FUNCNAME[*]:-script}" "$?" "$BASH_COMMAND"' ERR

# Set magic variables for current file, directory, os, etc.
__dir="$(cd "$(dirname "${BASH_SOURCE[${__b3bp_tmp_source_idx:-0}]}")" && pwd)"
__file="${__dir}/$(basename "${BASH_SOURCE[${__b3bp_tmp_source_idx:-0}]}")"
__base="$(basename "${__file}" .sh)"
# shellcheck disable=SC2034,SC2015
__invocation="$(printf %q "${__file}")$( (($#)) && printf ' %q' "$@" || true)"

if [[ ${_arg_debug} == "on" ]]; then
  LOG_LEVEL=7
  set -x
else
  LOG_LEVEL=6
fi

function __b3bp_log() {
  local log_level="${1}"
  shift

  # shellcheck disable=SC2034
  local color_debug="\\x1b[35m" #]
  # shellcheck disable=SC2034
  local color_info="\\x1b[32m" #]
  # shellcheck disable=SC2034
  local color_notice="\\x1b[34m" #]
  # shellcheck disable=SC2034
  local color_warning="\\x1b[33m" #]
  # shellcheck disable=SC2034
  local color_error="\\x1b[31m" #]
  # shellcheck disable=SC2034
  local color_critical="\\x1b[1;31m" #]
  # shellcheck disable=SC2034
  local color_alert="\\x1b[1;37;41m" #]
  # shellcheck disable=SC2034
  local color_failure="\\x1b[1;4;5;37;41m" #]

  local colorvar="color_${log_level}"

  local color="${!colorvar:-${color_error}}"
  local color_reset="\\x1b[0m" #]

  if [[ "${NO_COLOR:-}" = "true" ]] || { [[ "${TERM:-}" != "xterm"* ]] && [[ "${TERM:-}" != "screen"* ]]; } || [[ ! -t 2 ]]; then
    if [[ "${NO_COLOR:-}" != "false" ]]; then
      # Don't use colors on pipes or non-recognized terminals
      color=""
      color_reset=""
    fi
  fi

  # all remaining arguments are to be printed
  local log_line=""

  while IFS=$'\n' read -r log_line; do
    echo -e "$(date -u +"%Y-%m-%d %H:%M:%S UTC") ${color}$(printf "[%9s]" "${log_level}")${color_reset} ${log_line}" 1>&2
  done <<<"${@:-}"
}

function failure() {
  __b3bp_log failure "${@}"
  exit 1
}
function alert() {
  [[ "${LOG_LEVEL:-0}" -ge 1 ]] && __b3bp_log alert "${@}"
  true
}
function critical() {
  [[ "${LOG_LEVEL:-0}" -ge 2 ]] && __b3bp_log critical "${@}"
  true
}
function error() {
  [[ "${LOG_LEVEL:-0}" -ge 3 ]] && __b3bp_log error "${@}"
  true
}
function warning() {
  [[ "${LOG_LEVEL:-0}" -ge 4 ]] && __b3bp_log warning "${@}"
  true
}
function notice() {
  [[ "${LOG_LEVEL:-0}" -ge 5 ]] && __b3bp_log notice "${@}"
  true
}
function info() {
  [[ "${LOG_LEVEL:-0}" -ge 6 ]] && __b3bp_log info "${@}"
  true
}
function debug() {
  [[ "${LOG_LEVEL:-0}" -ge 7 ]] && __b3bp_log debug "${@}"
  true
}

tmpdir=$(mktemp -d)
# Setup exit trap for cleanup, don't do if debug
function finish() {
  if [[ ${_arg_debug} == "off" ]]; then
    rm -rf "${tmpdir}"
  else
    echo "Debug enabled, temporary files at ${tmpdir} have not been cleaned up"
  fi
}
trap finish EXIT

# Calculator used everywhere
function calc() { awk "BEGIN{ printf $* }"; }

function make_qc() {
  # Generate a standardized view of the final correct brain in MNI space, with classification overlayed
  # Create animated version if img2webp is available
  mkdir -p ${tmpdir}/qc

  # Resample into MNI space for all the inputs for standard visualization
  # Classification
  antsApplyTransforms -d 3 ${MNI_XFM:+-t ${MNI_XFM}} -t ${tmpdir}/to_model_0_GenericAffine.xfm \
    -i ${tmpdir}/classify.mnc -o ${tmpdir}/qc/classify.mnc -r ${RESAMPLEMODEL} -n GenericLabel

  # Masks
  antsApplyTransforms -d 3 ${MNI_XFM:+-t ${MNI_XFM}} -t ${tmpdir}/to_model_0_GenericAffine.xfm \
    -i ${tmpdir}/mask_nocsf_resample_filled.mnc -o ${tmpdir}/qc/mask.mnc -r ${RESAMPLEMODEL} -n GenericLabel

  # Final Corrected Image
  antsApplyTransforms -d 3 ${MNI_XFM:+-t ${MNI_XFM}} -t ${tmpdir}/to_model_0_GenericAffine.xfm \
    -i ${tmpdir}/corrected_denoise_scaled.mnc -o ${tmpdir}/qc/corrected.mnc -r ${RESAMPLEMODEL} -n BSpline[5]

  # Final Corrected Image with nlin
  antsApplyTransforms -d 3 ${MNI_XFM:+-t ${MNI_XFM}} -t ${tmpdir}/to_model_1_NL.xfm -t ${tmpdir}/to_model_0_GenericAffine.xfm \
    -i ${tmpdir}/corrected_denoise_scaled.mnc -o ${tmpdir}/qc/corrected_nlin.mnc -r ${RESAMPLEMODEL} -n BSpline[5]

  # Original input image
  antsApplyTransforms -d 3 ${MNI_XFM:+-t ${MNI_XFM}} -t ${tmpdir}/to_model_0_GenericAffine.xfm \
    -i ${tmpdir}/origqcref.mnc -o ${tmpdir}/qc/orig.mnc -r ${RESAMPLEMODEL} -n BSpline[5]

  # Resample REGISTRATIONOUTLINE and use it if defined
  if [[ -s ${REGISTRATIONOUTLINE:-} ]]; then
    antsApplyTransforms -d 3 ${MNI_XFM:+-t ${MNI_XFM}} \
      -i ${REGISTRATIONOUTLINE} -o ${tmpdir}/qc/outline.mnc -r ${RESAMPLEMODEL} -n GenericLabel
    RESAMPLEOUTLINE=${tmpdir}/qc/outline.mnc
  fi

  mincmath -clobber -quiet -clamp -const2 0 65535 ${tmpdir}/qc/corrected.mnc ${tmpdir}/qc/corrected.clamp.mnc
  mv -f ${tmpdir}/qc/corrected.clamp.mnc ${tmpdir}/qc/corrected.mnc
  mincmath -clobber -quiet -clamp -const2 0 65535 ${tmpdir}/qc/orig.mnc ${tmpdir}/qc/orig.clamp.mnc
  mv -f ${tmpdir}/qc/orig.clamp.mnc ${tmpdir}/qc/orig.mnc
  mincmath -clobber -quiet -clamp -const2 0 65535 ${tmpdir}/qc/corrected_nlin.mnc ${tmpdir}/qc/corrected.clamp.mnc
  mv -f ${tmpdir}/qc/corrected.clamp.mnc ${tmpdir}/qc/corrected_nlin.mnc

  # Create the bounding box for create_verify_image
  mincresample -clobber -quiet $(mincbbox -mincresample ${tmpdir}/qc/classify.mnc) ${tmpdir}/qc/classify.mnc ${tmpdir}/qc/label-crop.mnc
  minccalc -quiet -unsigned -byte -expression '1' ${tmpdir}/qc/label-crop.mnc ${tmpdir}/qc/bounding.mnc

  # Create Building Block Slices
  for slicedir in t s c; do
    # Corrected image in gray
    create_verify_image -range_floor 0 ${tmpdir}/qc/${slicedir}_corrected_gray.rgb \
      -width 1920 -autocols 10 -autocol_planes ${slicedir} \
      -bounding_volume ${tmpdir}/qc/bounding.mnc \
      -row ${tmpdir}/qc/corrected.mnc color:gray:0:65535

    # Corrected image in spectral
    create_verify_image -range_floor 0 ${tmpdir}/qc/${slicedir}_corrected_spect.rgb \
      -width 1920 -autocols 10 -autocol_planes ${slicedir} \
      -bounding_volume ${tmpdir}/qc/bounding.mnc \
      -row ${tmpdir}/qc/corrected.mnc color:spect:0:65535

    # Original image in gray
    create_verify_image -range_floor 0 ${tmpdir}/qc/${slicedir}_orig_gray.rgb \
      -width 1920 -autocols 10 -autocol_planes ${slicedir} \
      -bounding_volume ${tmpdir}/qc/bounding.mnc \
      -row ${tmpdir}/qc/orig.mnc color:gray:0:65535

    # Original image in spectral
    create_verify_image -range_floor 0 ${tmpdir}/qc/${slicedir}_orig_spect.rgb \
      -width 1920 -autocols 10 -autocol_planes ${slicedir} \
      -bounding_volume ${tmpdir}/qc/bounding.mnc \
      -row ${tmpdir}/qc/orig.mnc color:spect:0:65535

    # Corrected image with classification
    create_verify_image -range_floor 0 ${tmpdir}/qc/${slicedir}_classified.rgb \
      -width 1920 -autocols 10 -autocol_planes ${slicedir} \
      -bounding_volume ${tmpdir}/qc/bounding.mnc \
      -row ${tmpdir}/qc/corrected.mnc color:gray:0:65535 \
      volume_overlay:${tmpdir}/qc/classify.mnc:0.4

    # Corrected image with mask
    create_verify_image -range_floor 0 ${tmpdir}/qc/${slicedir}_mask.rgb \
      -width 1920 -autocols 10 -autocol_planes ${slicedir} \
      -bounding_volume ${tmpdir}/qc/bounding.mnc \
      -row ${tmpdir}/qc/corrected.mnc color:gray:0:65535 \
      volume_overlay:${tmpdir}/qc/mask.mnc:0.4:red

    # Corrected image with outline
    create_verify_image -range_floor 0 ${tmpdir}/qc/${slicedir}_outline.rgb \
      -width 1920 -autocols 10 -autocol_planes ${slicedir} \
      -bounding_volume ${tmpdir}/qc/bounding.mnc \
      -row ${tmpdir}/qc/corrected.mnc color:gray:0:65535 \
      volume_overlay:${RESAMPLEOUTLINE}:0.7:red

    # Corrected image with nlin outline
    create_verify_image -range_floor 0 ${tmpdir}/qc/${slicedir}_nlin_outline.rgb \
      -width 1920 -autocols 10 -autocol_planes ${slicedir} \
      -bounding_volume ${tmpdir}/qc/bounding.mnc \
      -row ${tmpdir}/qc/corrected_nlin.mnc color:gray:0:65535 \
      volume_overlay:${RESAMPLEOUTLINE}:0.7:red
  done

  convert -background black -strip -append \
    -interlace Plane -sampling-factor 4:2:0 -quality "85%" \
    ${tmpdir}/qc/c_orig_spect.rgb \
    ${tmpdir}/qc/c_corrected_spect.rgb \
    ${tmpdir}/qc/s_orig_spect.rgb \
    ${tmpdir}/qc/s_corrected_spect.rgb \
    ${tmpdir}/qc/t_orig_spect.rgb \
    ${tmpdir}/qc/t_corrected_spect.rgb \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.bias.jpg

  convert -background black -strip -append \
    -interlace Plane -sampling-factor 4:2:0 -quality "85%" \
    ${tmpdir}/qc/c_mask.rgb \
    ${tmpdir}/qc/c_classified.rgb \
    ${tmpdir}/qc/s_mask.rgb \
    ${tmpdir}/qc/s_classified.rgb \
    ${tmpdir}/qc/t_mask.rgb \
    ${tmpdir}/qc/t_classified.rgb \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.mask.classified.jpg

  convert -background black -strip -append \
    -interlace Plane -sampling-factor 4:2:0 -quality "85%" \
    ${tmpdir}/qc/c_outline.rgb \
    ${tmpdir}/qc/c_nlin_outline.rgb \
    ${tmpdir}/qc/s_outline.rgb \
    ${tmpdir}/qc/s_nlin_outline.rgb \
    ${tmpdir}/qc/t_outline.rgb \
    ${tmpdir}/qc/t_nlin_outline.rgb \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.registration.jpg

  # If webp software is available animate a before/after image
  if command -v img2webp; then
    img2webp -d 1000 -lossy -min_size \
      $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.bias.jpg \
      $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.mask.classified.jpg \
      $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.registration.jpg \
      -o $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.webp || true
  fi
}

lsq12_to_lsq6() {
  local input=$1
  local output=$2

  local tmpdir=$(mktemp -d)

  param2xfm $(xfm2param ${input} | grep -E 'scale|shear') ${tmpdir}/scaleshear.xfm
  xfminvert ${tmpdir}/scaleshear.xfm ${tmpdir}/unscaleshear.xfm
  xfmconcat ${tmpdir}/unscaleshear.xfm ${input} ${output}

  rm -rf ${tmpdir}
}

# Iterative multi-scale N3 implementation
hierarchical_N3() {
  local input=${1}
  local weight=${2}
  local fovmask=${3}
  local starting_distance=${4}
  local n3_levels=${5}
  local cycles=${6}
  local iters=${7}
  local output=${8}
  local field_output=${9}
  local tmpdir=$(mktemp -d)

  cp ${input} ${tmpdir}/input.mnc
  input=${tmpdir}/input.mnc

  minc_anlm --short --mt $(nproc) ${input} ${tmpdir}/denoised.mnc
  ResampleImage 3 ${tmpdir}/denoised.mnc ${tmpdir}/isoinput.mnc ${_arg_isostep}x${_arg_isostep}x${_arg_isostep} 0 1
  n3input=${tmpdir}/isoinput.mnc

  minccalc -clobber -unsigned -byte -expression 'A[0]>1?1:0' ${tmpdir}/isoinput.mnc ${tmpdir}/nonzero.mnc
  antsApplyTransforms -d 3 -i ${weight} -o ${tmpdir}/tmpweight.mnc -r ${n3input} -n GenericLabel
  ImageMath 3 ${tmpdir}/tmpweight.mnc m ${tmpdir}/tmpweight.mnc ${tmpdir}/nonzero.mnc

  distance=${starting_distance}

  j=0
  while ((j < n3_levels)); do
    i=0
    while ((i < cycles)); do
      nu_correct -normalize_field \
        -stop ${_arg_stop} -distance ${distance} -iterations ${iters} -fwhm ${_arg_fwhm} -shrink 1 -lambda ${_arg_lambda} \
        -mask ${tmpdir}/tmpweight.mnc ${n3input} ${tmpdir}/corrected_${distance}_${i}.mnc

      n3input=${tmpdir}/corrected_${distance}_${i}.mnc

      ((++i))
    done
    distance=$(calc "${distance} / 2")
    ((++j))
  done

  for file in ${tmpdir}/*imp; do
    echo evaluate_field -unsigned -double -clobber -like ${input} ${file} ${tmpdir}/$(basename ${file} .imp)_field.mnc
  done | parallel -j $(nproc)

  mincmath -clobber -unsigned -double -mult ${tmpdir}/*_field.mnc ${tmpdir}/field_combined.mnc

  correct_field ${tmpdir}/field_combined.mnc ${fovmask} ${tmpdir}/field_combined_correct.mnc

  minccalc -clobber -unsigned -int -expression "A[0]/A[1]" ${input} \
    ${tmpdir}/field_combined_correct.mnc ${output}

  cp -f ${tmpdir}/field_combined_correct.mnc ${field_output}
  rm -rf ${tmpdir}
}

# Output checking
if [[ "${_arg_clobber}" == "off" ]]; then
  for file in ${_arg_output} \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).mask_nocsf.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).mask_withcsf.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).classify.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).posterior1.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).posterior2.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).posterior3.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).posterior4.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).denoise.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).affine_to_model.xfm \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).nlin_to_model.xfm \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).nlin_from_model.xfm \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).ICV.xfm \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.webp \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.mask.classified.jpg \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.bias.jpg \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).qc.registration.jpg \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.mask_nocsf.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.mask_withcsf.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.classify.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.posterior1.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.posterior2.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.posterior3.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.posterior4.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.denoise.mnc; do
    if [[ -s "${file}" ]]; then
      failure "File ${file} already exists and --clobber not specified!"
    fi
  done
fi

RESAMPLEMODEL="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_t1_tal_nlin_sym_09c.mnc"
RESAMPLEMASK="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_t1_tal_nlin_sym_09c_mask.mnc"
RESAMPLEOUTLINE="${QUARANTINE_PATH}/resources/mni_icbm152_nlin_sym_09c_minc2/mni_icbm152_t1_tal_nlin_sym_09c_outline.mnc"

# Load configuration
if [[ -s ${_arg_prior_config} ]]; then
  source ${_arg_prior_config}
elif [[ -s ${__dir}/configs/${_arg_prior_config} ]]; then
  source ${__dir}/configs/${_arg_prior_config}
else
  failure "${_arg_prior_config} not found"
fi

if [[ ${_arg_input} == *.nii || ${_arg_input} == *.nii.gz ]]; then
  # Fix sometimes malformed niftis
  ConvertImage 3 ${_arg_input} ${tmpdir}/input.nii.gz
  nii2mnc ${tmpdir}/input.nii.gz ${tmpdir}/input.mnc
  input=${tmpdir}/input.mnc
else
  input=${_arg_input}
fi

# Calulate a scaling factor for mm from isostep
dx=$(mincinfo -attvalue xspace:step ${input})
dy=$(mincinfo -attvalue yspace:step ${input})
dz=$(mincinfo -attvalue zspace:step ${input})
scale_factor=$(python -c "print(1.0 / ( ( abs(${dx}) + abs(${dy}) + abs(${dz}) ) / 3.0 ))")

# Change the slicing direction to be the same as what ITK outputs by default
mincreshape -dimorder zspace,yspace,xspace +direction ${input} ${tmpdir}/reshape1.mnc
mincreshape -dimorder zspace,yspace,xspace +direction ${tmpdir}/reshape1.mnc ${tmpdir}/reshape2.mnc
rm -f ${tmpdir}/reshape1.mnc

# Store the direction cosine transform because we're going to zero out the file
dircos_to_xfm ${tmpdir}/reshape2.mnc ${tmpdir}/transform_to_input.xfm
# Square up direction cosines
minc_modify_header -dinsert xspace:direction_cosines=1,0,0 ${tmpdir}/reshape2.mnc
minc_modify_header -dinsert yspace:direction_cosines=0,1,0 ${tmpdir}/reshape2.mnc
minc_modify_header -dinsert zspace:direction_cosines=0,0,1 ${tmpdir}/reshape2.mnc

# Clamp above 0 and normalize using 0.1% histogram
mincmath -unsigned -clamp -const2 0 1.79769e+308 ${tmpdir}/reshape2.mnc ${tmpdir}/clamp.mnc
mincnorm -out_ceil 65535 -out_floor 0 -short -cutoff 0.001 ${tmpdir}/clamp.mnc ${tmpdir}/norm_input.mnc

cp -f ${tmpdir}/norm_input.mnc ${tmpdir}/origqcref.mnc

# Pad a little bit to avoid edge effects
volpad -distance $(calc "int(${scale_factor}*20)") ${tmpdir}/norm_input.mnc ${tmpdir}/norm_input_padded.mnc

input=${tmpdir}/norm_input_padded.mnc

# First denoise the uncorrected input file
minc_anlm --short --mt $(nproc) ${input} ${tmpdir}/norm_input_padded_denoise.mnc
input_denoise=${tmpdir}/norm_input_padded_denoise.mnc

# Construct a foreground mask using Otsu thresholding
minccalc -clobber -quiet -expression 'A[0]>0?1:0' ${input_denoise} ${tmpdir}/nonzero.mnc
ThresholdImage 3 ${input_denoise} ${tmpdir}/fgmask.mnc Otsu 4 ${tmpdir}/nonzero.mnc
ThresholdImage 3 ${tmpdir}/fgmask.mnc ${tmpdir}/fgmask.mnc 1.5 Inf 1 0
ImageMath 3 ${tmpdir}/fgmask.mnc GetLargestComponent ${tmpdir}/fgmask.mnc
iMath 3 ${tmpdir}/fgmask.mnc MD ${tmpdir}/fgmask.mnc $(calc "int(${scale_factor}*2)") 1 ball 1
ImageMath 3 ${tmpdir}/fgmask.mnc FillHoles ${tmpdir}/fgmask.mnc 2

# Precorrect Round 1
hierarchical_N3 ${input} ${tmpdir}/fgmask.mnc ${tmpdir}/fgmask.mnc 400 2 ${_arg_cycles} 100 ${tmpdir}/precorrect1.mnc ${tmpdir}/precorrect1_field.mnc

# Now denoise the first precorrect
minc_anlm --short --mt $(nproc) ${tmpdir}/precorrect1.mnc ${tmpdir}/precorrect1_denoise.mnc
input_denoise=${tmpdir}/precorrect1_denoise.mnc

# Reconstruct a foreground mask using Otsu thresholding
# ThresholdImage 3 ${input_denoise} ${tmpdir}/nonzero.mnc 1e-6 Inf 1 0
minccalc -clobber -quiet -expression 'A[0]>0?1:0' ${input_denoise} ${tmpdir}/nonzero.mnc
ThresholdImage 3 ${input_denoise} ${tmpdir}/fgmask.mnc Otsu 4 ${tmpdir}/nonzero.mnc
ThresholdImage 3 ${tmpdir}/fgmask.mnc ${tmpdir}/fgmask.mnc 1.5 Inf 1 0
ImageMath 3 ${tmpdir}/fgmask.mnc GetLargestComponent ${tmpdir}/fgmask.mnc
iMath 3 ${tmpdir}/fgmask.mnc MD ${tmpdir}/fgmask.mnc $(calc "int(${scale_factor}*2)") 1 ball 1
ImageMath 3 ${tmpdir}/fgmask.mnc FillHoles ${tmpdir}/fgmask.mnc 2

# Make a foreground mask now from the FOV mask
ThresholdImage 3 ${input_denoise} ${tmpdir}/fgweight.mnc Otsu 4 ${tmpdir}/fgmask.mnc
ThresholdImage 3 ${tmpdir}/fgweight.mnc ${tmpdir}/fgweight.mnc 1.5 Inf 1 0

# Need nifti for synthstrip
mnc2nii -quiet ${input_denoise} ${tmpdir}/precorrect1_denoise.nii
mnc2nii -quiet ${REGISTRATIONMODEL} ${tmpdir}/model.nii

synthstrip -i ${tmpdir}/precorrect1_denoise.nii \
  -m ${tmpdir}/mask_withcsf.nii.gz -o ${tmpdir}/precorrect1_denoise_extracted.nii.gz

nii2mnc ${tmpdir}/precorrect1_denoise_extracted.nii.gz ${tmpdir}/precorrect1_denoise_extracted.mnc

synthstrip -i ${tmpdir}/model.nii \
  -m ${tmpdir}/model_mask.nii.gz -o ${tmpdir}/model_extracted.nii.gz

nii2mnc ${tmpdir}/model_extracted.nii.gz ${tmpdir}/model_extracted.mnc

nii2mnc -quiet -unsigned -byte -clobber ${tmpdir}/mask_withcsf.nii.gz ${tmpdir}/mask_withcsf.mnc
nii2mnc -quiet -unsigned -byte -clobber ${tmpdir}/model_mask.nii.gz ${tmpdir}/model_mask.mnc

# Register to MNI model to use its foreground mask and FOV
antsRegistration_affine_SyN.sh --skip-nonlinear \
  ${tmpdir}/precorrect1_denoise_extracted.mnc \
  ${tmpdir}/model_extracted.mnc \
  ${tmpdir}/to_model_

minccalc -clobber -unsigned -byte -expression '1' ${REGISTRATIONMODEL} ${tmpdir}/model_fovmask.mnc

# Pad a bunch so we can do an extraction
volpad -distance $(calc "int(${scale_factor}*50)") ${input} ${tmpdir}/padded_input.mnc

# Transform the masks to match the padded image
antsApplyTransforms -d 3 -i ${tmpdir}/model_fovmask.mnc -t [ ${tmpdir}/to_model_0_GenericAffine.xfm,1 ] \
  -o ${tmpdir}/subject_fovmask.mnc -r ${tmpdir}/padded_input.mnc -n GenericLabel
antsApplyTransforms -d 3 -i ${tmpdir}/fgmask.mnc \
  -o ${tmpdir}/fgmask.mnc -r ${tmpdir}/padded_input.mnc -n GenericLabel

# Delete the background
minccalc -expression 'A[0]*A[1]*A[2]' ${tmpdir}/padded_input.mnc ${tmpdir}/subject_fovmask.mnc ${tmpdir}/fgmask.mnc ${tmpdir}/padded_input_extracted.mnc
minccalc -unsigned -byte -expression 'A[0]*A[1]' ${tmpdir}/subject_fovmask.mnc ${tmpdir}/fgmask.mnc ${tmpdir}/subject_fovmask_fgmask.mnc

# Extract using the FOV
ExtractRegionFromImageByMask 3 ${tmpdir}/padded_input_extracted.mnc \
  ${tmpdir}/norm_input_extracted_repad.mnc ${tmpdir}/subject_fovmask_fgmask.mnc 1 $(calc "int(${scale_factor}*20)")

antsApplyTransforms -d 3 -n GenericLabel \
  -i ${tmpdir}/fgweight.mnc \
  -r ${tmpdir}/norm_input_extracted_repad.mnc \
  -o ${tmpdir}/fgweight.mnc

# Start again using the corrected FOV input
input=${tmpdir}/norm_input_extracted_repad.mnc

# Precorrect Round 2
hierarchical_N3 ${input} ${tmpdir}/fgweight.mnc ${tmpdir}/fgweight.mnc 400 2 ${_arg_cycles} ${_arg_iters} \
  ${tmpdir}/precorrect2.mnc ${tmpdir}/precorrect2_field.mnc

# DenoiseImage -d 3 -i ${tmpdir}/precorrect2.mnc -o ${tmpdir}/precorrect2_denoise.mnc
minc_anlm --short --mt $(nproc) ${tmpdir}/precorrect2.mnc ${tmpdir}/precorrect2_denoise.mnc

mnc2nii -quiet ${tmpdir}/precorrect2_denoise.mnc ${tmpdir}/precorrect2_denoise.nii

# Generate brain masks
synthstrip -i ${tmpdir}/precorrect2_denoise.nii \
  -m ${tmpdir}/mask_nocsf.nii.gz --no-csf

synthstrip -i ${tmpdir}/precorrect2_denoise.nii \
  -m ${tmpdir}/mask_withcsf.nii.gz -o ${tmpdir}/precorrect2_denoise_extracted.nii.gz

nii2mnc -quiet -clobber ${tmpdir}/mask_withcsf.nii.gz ${tmpdir}/mask_withcsf.mnc
nii2mnc -quiet -clobber ${tmpdir}/mask_nocsf.nii.gz ${tmpdir}/mask_nocsf.mnc
nii2mnc -quiet -clobber ${tmpdir}/precorrect2_denoise_extracted.nii.gz ${tmpdir}/precorrect2_denoise_extracted.mnc

antsRegistration_affine_SyN.sh --clobber \
  --initial-transform ${tmpdir}/to_model_0_GenericAffine.xfm \
  ${tmpdir}/precorrect2_denoise_extracted.mnc \
  ${tmpdir}/model_extracted.mnc \
  ${tmpdir}/to_model_

# Otsu threshold the brain mask to get a mask with no ventricles
ThresholdImage 3 ${tmpdir}/precorrect2_denoise.nii ${tmpdir}/otsu.nii Otsu 4 ${tmpdir}/mask_nocsf.nii.gz
ThresholdImage 3 ${tmpdir}/otsu.nii ${tmpdir}/weight.nii 1.5 Inf 1 0
nii2mnc -quiet ${tmpdir}/weight.nii ${tmpdir}/weight.mnc

hierarchical_N3 ${tmpdir}/precorrect2.mnc ${tmpdir}/weight.mnc ${tmpdir}/mask_withcsf.mnc \
  ${_arg_distance} ${_arg_levels} ${_arg_cycles} ${_arg_iters} \
  ${tmpdir}/corrected.mnc ${tmpdir}/correct_field.mnc

# Correct the original input brain to have mean 32767
origmean=$(mincstats -mean -quiet -mask ${tmpdir}/weight.mnc -mask_binvalue 1 ${input})
minccalc -clobber -unsigned -int -expression "((A[0]/${origmean})/(A[1]*A[2]))*32767" \
  ${input} ${tmpdir}/precorrect2_field.mnc ${tmpdir}/correct_field.mnc ${tmpdir}/corrected.mnc

minc_anlm --double --mt $(nproc) ${tmpdir}/corrected.mnc ${tmpdir}/corrected_denoise.mnc

# Do a soft segmentation of the brain
antsApplyTransforms -d 3 -n GenericLabel \
  -i ${tmpdir}/mask_nocsf.mnc \
  -r ${tmpdir}/corrected_denoise.mnc \
  -o ${tmpdir}/mask_nocsf.mnc

if [[ -s ${DEEPGMPRIOR:-} ]]; then
  antsApplyTransforms -d 3 -i ${DEEPGMPRIOR} -t [ ${tmpdir}/to_model_0_GenericAffine.xfm,1 ] \
    -t ${tmpdir}/to_model_1_inverse_NL.xfm \
    -n Linear --verbose \
    -r ${tmpdir}/corrected_denoise.mnc -o ${tmpdir}/prior4.mnc
fi
antsApplyTransforms -d 3 -i ${WMPRIOR} -t [ ${tmpdir}/to_model_0_GenericAffine.xfm,1 ] \
  -t ${tmpdir}/to_model_1_inverse_NL.xfm \
  -n Linear --verbose \
  -r ${tmpdir}/corrected_denoise.mnc -o ${tmpdir}/prior3.mnc
antsApplyTransforms -d 3 -i ${GMPRIOR} -t [ ${tmpdir}/to_model_0_GenericAffine.xfm,1 ] \
  -t ${tmpdir}/to_model_1_inverse_NL.xfm \
  -n Linear --verbose \
  -r ${tmpdir}/corrected_denoise.mnc -o ${tmpdir}/prior2.mnc
antsApplyTransforms -d 3 -i ${CSFPRIOR} -t [ ${tmpdir}/to_model_0_GenericAffine.xfm,1 ] \
  -t ${tmpdir}/to_model_1_inverse_NL.xfm \
  -n Linear --verbose \
  -r ${tmpdir}/corrected_denoise.mnc -o ${tmpdir}/prior1.mnc

ImageMath 3 ${tmpdir}/mask_nocsf_resample_filled.mnc FillHoles ${tmpdir}/mask_nocsf.mnc 2

# Do a classification
if [[ -n ${DEEPGMPRIOR:-} ]]; then
  Atropos -d 3 \
    -m [ 0.1,1x1x1 ] \
    -c [ 25, 0.005 ] \
    -i PriorProbabilityImages[ 4,${tmpdir}/prior%d.mnc,0.25 ] \
    -k HistogramParzenWindows[ 1, 32 ] \
    -p Aristotle[ 1 ] \
    -a ${tmpdir}/corrected_denoise.mnc \
    -x ${tmpdir}/mask_nocsf_resample_filled.mnc \
    -s 1x2 -s 2x3 -s 1x3 -s 1x4 -s 3x4 \
    -l [ 0.69314718055994530942,1 ] \
    --winsorize-outliers BoxPlot \
    -o ${tmpdir}/classify.mnc
else
  Atropos -d 3 \
    -m [ 0.1,1x1x1 ] \
    -c [ 25, 0.005 ] \
    -i PriorProbabilityImages[ 3,${tmpdir}/prior%d.mnc,0.25 ] \
    -k HistogramParzenWindows[ 1, 32 ] \
    -p Aristotle[ 1 ] \
    -a ${tmpdir}/corrected_denoise.mnc \
    -x ${tmpdir}/mask_nocsf_resample_filled.mnc \
    -s 1x2 -s 2x3 -s 1x3 \
    -l [ 0.69314718055994530942,1 ] \
    --winsorize-outliers BoxPlot \
    -o ${tmpdir}/classify.mnc
fi

# Correct with WM mask
minccalc -clobber -unsigned -byte -expression 'A[0]==3?1:0' ${tmpdir}/classify.mnc ${tmpdir}/weight_wm.mnc

# Correct Round 3
hierarchical_N3 ${tmpdir}/corrected.mnc ${tmpdir}/weight_wm.mnc ${tmpdir}/mask_withcsf.mnc \
  ${_arg_distance} ${_arg_levels} ${_arg_cycles} ${_arg_iters} \
  ${tmpdir}/corrected_wm.mnc ${tmpdir}/correct_field_wm.mnc

# Correct the original input brain to have mean 32767
origmean=$(mincstats -mean -quiet -mask_range 1.5,4.5 -mask ${tmpdir}/classify.mnc ${input})

minccalc -clobber -unsigned -int -expression "((A[0]/${origmean})/(A[1]*A[2]*A[3]))*32767" \
  ${input} ${tmpdir}/precorrect2_field.mnc ${tmpdir}/correct_field.mnc ${tmpdir}/correct_field_wm.mnc ${tmpdir}/corrected2.mnc

minc_anlm --clobber --double --mt $(nproc) ${tmpdir}/corrected2.mnc ${tmpdir}/corrected_denoise.mnc

# redo classification
if [[ -n ${DEEPGMPRIOR:-} ]]; then
  Atropos -d 3 \
    -m [ 0.1,1x1x1 ] \
    -c [ 25, 0.005 ] \
    -i PriorProbabilityImages[ 4,${tmpdir}/prior%d.mnc,0.25 ] \
    -k HistogramParzenWindows[ 1, 32 ] \
    -p Aristotle[ 1 ] \
    -a ${tmpdir}/corrected_denoise.mnc \
    -x ${tmpdir}/mask_nocsf_resample_filled.mnc \
    -s 1x2 -s 2x3 -s 1x3 -s 1x4 -s 3x4 \
    -l [ 0.69314718055994530942,1 ] \
    --winsorize-outliers BoxPlot \
    -o ${tmpdir}/classify.mnc
else
  Atropos -d 3 \
    -m [ 0.1,1x1x1 ] \
    -c [ 25, 0.005 ] \
    -i PriorProbabilityImages[ 3,${tmpdir}/prior%d.mnc,0.25 ] \
    -k HistogramParzenWindows[ 1, 32 ] \
    -p Aristotle[ 1 ] \
    -a ${tmpdir}/corrected_denoise.mnc \
    -x ${tmpdir}/mask_nocsf_resample_filled.mnc \
    -s 1x2 -s 2x3 -s 1x3 \
    -l [ 0.69314718055994530942,1 ] \
    --winsorize-outliers BoxPlot \
    -o ${tmpdir}/classify.mnc
fi

wm_mean=$(mincstats -mean -quiet -mask ${tmpdir}/classify.mnc -mask_binvalue 3 ${tmpdir}/corrected_denoise.mnc)

# Use the white matter mean to do a sigmoid transformation on the values
# Stolen from OMM modelbuilder
minccalc -unsigned -short -expression "clamp((A[0]<${wm_mean})?A[0]:(${wm_mean}/(2*(1+exp(-8*(A[0]-${wm_mean})/${wm_mean}))) + 0.75*${wm_mean}),0,65535)" \
  ${tmpdir}/corrected_denoise.mnc ${tmpdir}/corrected_denoise_scaled.mnc
minccalc -unsigned -short -expression "clamp((A[0]<${wm_mean})?A[0]:(${wm_mean}/(2*(1+exp(-8*(A[0]-${wm_mean})/${wm_mean}))) + 0.75*${wm_mean}),0,65535)" \
  ${tmpdir}/corrected2.mnc ${tmpdir}/corrected_scaled.mnc

make_qc

mincresample -clobber -unsigned -short -tfm_input_sampling \
  -transform ${tmpdir}/transform_to_input.xfm ${tmpdir}/corrected_scaled.mnc \
  ${_arg_output}
mincresample -clobber -unsigned -short -tfm_input_sampling \
  -transform ${tmpdir}/transform_to_input.xfm ${tmpdir}/corrected_denoise_scaled.mnc \
  $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).denoise.mnc

mincresample -clobber -labels -unsigned -byte -tfm_input_sampling \
  -transform ${tmpdir}/transform_to_input.xfm ${tmpdir}/mask_withcsf.mnc \
  $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).mask_withcsf.mnc

mincresample -clobber -labels -unsigned -byte -tfm_input_sampling \
  -transform ${tmpdir}/transform_to_input.xfm ${tmpdir}/mask_nocsf_resample_filled.mnc \
  $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).mask_nocsf.mnc

mincresample -clobber -labels -unsigned -byte -tfm_input_sampling \
  -transform ${tmpdir}/transform_to_input.xfm ${tmpdir}/classify.mnc \
  $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).classify.mnc

cp -f ${tmpdir}/to_model_0_GenericAffine.xfm $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).affine_to_model.xfm
cp -f ${tmpdir}/to_model_1_NL.xfm $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).nlin_to_model.xfm
cp -f ${tmpdir}/to_model_1_inverse_NL.xfm $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).nlin_from_model.xfm

if [[ "${_arg_lsq6_resample_type}" != "none" ]]; then
  # Create LSQ6 version of affine transform
  lsq12_to_lsq6 ${tmpdir}/to_model_0_GenericAffine.xfm ${tmpdir}/lsq6.xfm

  if [[ ${_arg_lsq6_resample_type} == "coordinates" ]]; then
    mincresample -clobber -unsigned -short -tfm_input_sampling -transform ${tmpdir}/lsq6.xfm -invert_transform ${tmpdir}/corrected_scaled.mnc \
      $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.mnc
  else
    ResampleImage 3 ${RESAMPLEMODEL} ${tmpdir}/resamplemodel.mnc ${_arg_lsq6_resample_type}x${_arg_lsq6_resample_type}x${_arg_lsq6_resample_type} 0
    mincresample -clobber -unsigned -short -like ${tmpdir}/resamplemodel.mnc -transform ${tmpdir}/lsq6.xfm -invert_transform ${tmpdir}/corrected_scaled.mnc \
      $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.mnc
  fi

  cp -f ${tmpdir}/lsq6.xfm $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.xfm
  mincresample -clobber -unsigned -byte -labels \
    -transform ${tmpdir}/lsq6.xfm -invert_transform \
    -like $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.mnc \
    ${tmpdir}/mask_withcsf.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.mask_withcsf.mnc
  mincresample -clobber -unsigned -byte -labels \
    -transform ${tmpdir}/lsq6.xfm -invert_transform \
    -like $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.mnc \
    ${tmpdir}/mask_nocsf_resample_filled.mnc \
    $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.mask_nocsf.mnc

  mincresample -clobber -transform ${tmpdir}/lsq6.xfm -invert_transform -like $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.mnc \
    -keep -near -unsigned -byte -labels ${tmpdir}/classify.mnc $(dirname ${_arg_output})/$(basename ${_arg_output} .mnc).lsq6.classify.mnc
fi

# ] <-- needed because of Argbash
